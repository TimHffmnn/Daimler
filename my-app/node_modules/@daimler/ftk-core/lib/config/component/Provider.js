"use strict";
// SPDX-License-Identifier: MIT
// Copyright (c) 2020 Daimler TSS GmbH
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var lodash_1 = require("lodash");
var React = require("react");
var BindToDi_1 = require("../../di/component/BindToDi");
var withInject_1 = require("../../di/hoc/withInject");
var findBoundContainer_1 = require("../../di/lib/findBoundContainer");
var ConfigService_1 = require("../lib/ConfigService");
var defaultConfig = Object.seal({
    core: {
        i18n: {
            defaultLocale: 'de',
        },
    },
    project: {},
    runtime: {},
});
var Provider = /** @class */ (function (_super) {
    tslib_1.__extends(Provider, _super);
    function Provider() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.bindServices = lodash_1.once(function (container) {
            container.bind(ConfigService_1.ConfigService).toDynamicValue(function (context) {
                var config = defaultConfig;
                try {
                    var boundContainer = findBoundContainer_1.findBoundContainer(context.container, ConfigService_1.ConfigService);
                    // prevent a recursion loop if the configuration is bound in our own container
                    if (boundContainer.id !== context.container.id) {
                        config = boundContainer.get(ConfigService_1.ConfigService).getConfig();
                    }
                }
                catch (_a) {
                    // swallow the error; it means we have no config already bound and fallback to use the defaultConfig
                }
                var overwrittenConfig = _this.props.config || {};
                var merged = lodash_1.merge(tslib_1.__assign({}, config), overwrittenConfig);
                return new ConfigService_1.ConfigService(merged);
            });
        });
        return _this;
    }
    Provider.prototype.render = function () {
        return React.createElement(BindToDi_1.default, { services: this.bindServices }, this.props.children);
    };
    return Provider;
}(React.Component));
exports.ConfigProvider = withInject_1.default(Provider);
//# sourceMappingURL=Provider.js.map