"use strict";
// SPDX-License-Identifier: MIT
// Copyright (c) 2020 Daimler TSS GmbH
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var lodash_1 = require("lodash");
var React = require("react");
var ConfigService_1 = require("../../config/lib/ConfigService");
var serviceIds_1 = require("../../core/serviceIds");
var BindToDi_1 = require("../../di/component/BindToDi");
var inject_1 = require("../../di/hoc/inject");
var withInject_1 = require("../../di/hoc/withInject");
var TranslationMap_1 = require("../lib/TranslationMap");
/**
 * Deep-merges translation map trees together. The operation is immutable (neither input arg is mutated).
 * Lodash's merge() function is used for deep-merging.
 * The logic is:
 *   * Child translations overwrite parent translations (deep merge)
 *   * any overrides specific in the configuration (via see ConfigService, @see {ConfigService} ) is
 *     applied after the merge; that is configuration overrides are applied last and override any child
 *     translation.
 */
function mergeTranslations(parent, child, configTranslations) {
    var merged = TranslationMap_1.default.merge(parent, child);
    return TranslationMap_1.default.merge(merged, configTranslations);
}
/**
 * Looks up in the global app/swidget configuration if any translation overrides are defined an return them,
 * or an empty map if none are found.
 */
function getConfigTranslationMap(configService) {
    var config;
    try {
        config = configService.getConfig().core.i18n.map || {};
    }
    catch (e) {
        config = {};
    }
    return config;
}
/**
 * Allows to extend the current translations map. Note that the provided translations
 * are only made available to child components of the TranslationProvider, and will not affect
 * any global translations or similar.
 *
 * @example
 * <TranslationProvider translations={{de:{HELLOWORLD: 'Hallo welt!'}}}>
 *   <HelloWorldComponent />
 * </TranslationProvider>
 */
var Provider = /** @class */ (function (_super) {
    tslib_1.__extends(Provider, _super);
    function Provider() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.setupTranslations = lodash_1.once(function (container) {
            var parentTranslations = container.get(serviceIds_1.default.translations);
            var newTranslations = _this.props.translations;
            var configTranslations = getConfigTranslationMap(_this.configService);
            var mergedTranslations = mergeTranslations(parentTranslations, newTranslations, configTranslations);
            container.bind(serviceIds_1.default.translations).toConstantValue(mergedTranslations);
        });
        return _this;
    }
    Provider.prototype.render = function () {
        return React.createElement(BindToDi_1.default, { services: this.setupTranslations }, this.props.children);
    };
    tslib_1.__decorate([
        inject_1.default(),
        tslib_1.__metadata("design:type", ConfigService_1.ConfigService)
    ], Provider.prototype, "configService", void 0);
    return Provider;
}(React.Component));
exports.TranslationProvider = withInject_1.default(Provider);
//# sourceMappingURL=TranslationProvider.js.map