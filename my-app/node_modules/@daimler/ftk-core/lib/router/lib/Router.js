"use strict";
// SPDX-License-Identifier: MIT
// Copyright (c) 2020 Daimler TSS GmbH
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
var Registry_1 = require("../../util/Registry");
var RouteParser_1 = require("../../util/route/RouteParser");
var Url_1 = require("../../util/Url");
var Router = /** @class */ (function () {
    function Router() {
        this.routes = new Registry_1.Registry();
        this.route = null;
    }
    Router.prototype.navigate = function (path, query) {
        var _this = this;
        path = path || '/';
        if (!path.startsWith('/')) {
            path = "/" + path;
        }
        this.routes.forEach(function (item) {
            var parser = new RouteParser_1.RouteParser(item.pattern);
            var match = parser.match(path);
            if (match) {
                _this.route = lodash_1.assign({}, item, {
                    parameter: match,
                    query: query,
                    url: path + Url_1.default.buildQueryFromParameters(query),
                });
            }
        });
    };
    Router.prototype.addRoute = function (name, pattern, component, forceRemount) {
        this.routes.add(name, {
            component: component,
            forceRemount: forceRemount,
            name: name,
            pattern: pattern,
        });
    };
    Router.prototype.hasRoute = function (name) {
        return this.routes.has(name);
    };
    Router.prototype.removeRoute = function (name) {
        this.routes.remove(name);
    };
    Router.prototype.getActiveRoute = function () {
        return this.route;
    };
    Router.prototype.linkTo = function (name, parameter, query) {
        if (parameter === void 0) { parameter = {}; }
        if (query === void 0) { query = {}; }
        var pattern;
        try {
            pattern = this.routes.get(name).pattern;
        }
        catch (e) {
            throw new Error("Unknown route for link to route '" + name + "'.");
        }
        if (pattern.indexOf('*') !== -1) {
            pattern = pattern.substr(0, pattern.indexOf('*'));
        }
        var parser = new RouteParser_1.RouteParser(pattern);
        return parser.createPathString(parameter) + Url_1.default.buildQueryFromParameters(query);
    };
    return Router;
}());
exports.default = Router;
//# sourceMappingURL=Router.js.map